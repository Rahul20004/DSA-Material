//Brute approach (Sliding Window)
class Solution {
    public static int totalElements(Integer[] arr) {
        int maxLength = 0;

        for (int i = 0; i < arr.length; i++) {
            HashSet<Integer> set = new HashSet<>(); 
            for (int j = i; j < arr.length; j++) {
                set.add(arr[j]);           // subarray ‡§Æ‡•á‡§Ç element add ‡§ï‡§∞‡•ã
                if (set.size() > 2) break; // ‡§Ö‡§ó‡§∞ 2 ‡§∏‡•á ‡§ú‡•ç‡§Ø‡§æ‡§¶‡§æ distinct elements ‡§π‡•ã ‡§ó‡§è ‡§§‡•ã break

                maxLength = Math.max(maxLength, j - i + 1); // max length update ‡§ï‡§∞‡•ã
            }
        }

        return maxLength;
    }

  
}




// Explain
// To Summarize:
// Angle Brackets < > specify the type of the elements.
// Curly Braces { } are used for initializing elements inside a collection.

 For Practice

// class Solution{
//     public static int totalElements(Integer[] arr){
//         int maxLength = 0;
//         for(int i= 0; i<arr.length; i++){
//             HashSet<Integer> set = new HashSet<>();
//             for(int j= i; j<arr.length; j++){
//                 set.add(arr[j]);
//                 if(set.size() >2) break;
//                 maxLength = Math.max(maxLength, j-i+1);
//             }
//         }
//         return maxLength;
//     }
// }






Explain:
Code Explanation (‡§≤‡§æ‡§á‡§®-‡§¨‡§æ‡§Ø-‡§≤‡§æ‡§á‡§® ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§Æ‡•á‡§Ç)
1. Import ‡§î‡§∞ Class Definition
java
Copy
Edit
import java.util.HashSet;
‡§π‡§Æ HashSet ‡§á‡§Æ‡•ç‡§™‡•ã‡§∞‡•ç‡§ü ‡§ï‡§∞ ‡§∞‡§π‡•á ‡§π‡•à‡§Ç ‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø ‡§á‡§∏‡§∏‡•á ‡§π‡§Æ distinct (‡§Ö‡§≤‡§ó-‡§Ö‡§≤‡§ó) elements ‡§ï‡•ã store ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§
java
Copy
Edit
class Solution {
Solution ‡§®‡§æ‡§Æ ‡§ï‡•Ä ‡§è‡§ï class ‡§¨‡§®‡§æ‡§à ‡§ó‡§à ‡§π‡•à‡•§
2. totalElements() Method
java
Copy
Edit
public static int totalElements(Integer[] arr) {
totalElements() ‡§®‡§æ‡§Æ ‡§ï‡§æ ‡§è‡§ï static method ‡§π‡•à ‡§ú‡•ã Integer type ‡§ï‡•Ä array ‡§ï‡•ã input ‡§≤‡•á‡§§‡§æ ‡§π‡•à ‡§î‡§∞ int value return ‡§ï‡§∞‡§§‡§æ ‡§π‡•à‡•§
3. Variables Initialization
java
Copy
Edit
int maxLength = 0;
maxLength ‡§è‡§ï variable ‡§π‡•à ‡§ú‡•ã ‡§∏‡§¨‡§∏‡•á ‡§¨‡§°‡§º‡•á valid subarray ‡§ï‡•Ä length ‡§ï‡•ã store ‡§ï‡§∞‡•á‡§ó‡§æ‡•§
4. Outer Loop - Subarray ‡§ï‡•á ‡§∂‡•Å‡§∞‡•Å‡§Ü‡§§ ‡§ï‡§æ ‡§™‡•â‡§á‡§Ç‡§ü ‡§∏‡•á‡§ü ‡§ï‡§∞‡§®‡§æ
java
Copy
Edit
for (int i = 0; i < arr.length; i++) {
i ‡§∏‡•á loop ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞ ‡§∞‡§π‡•á ‡§π‡•à‡§Ç, ‡§Ø‡§π outer loop ‡§π‡§∞ index ‡§∏‡•á subarray ‡§¨‡§®‡§æ‡§®‡•á ‡§ï‡•Ä ‡§ï‡•ã‡§∂‡§ø‡§∂ ‡§ï‡§∞‡•á‡§ó‡§æ‡•§
5. Inner Loop - Subarray ‡§¨‡§®‡§æ‡§®‡§æ ‡§î‡§∞ ‡§ö‡•á‡§ï ‡§ï‡§∞‡§®‡§æ
java
Copy
Edit
HashSet<Integer> set = new HashSet<>();
‡§è‡§ï HashSet ‡§¨‡§®‡§æ‡§Ø‡§æ ‡§§‡§æ‡§ï‡§ø ‡§π‡§Æ unique elements ‡§ï‡•ã store ‡§ï‡§∞ ‡§∏‡§ï‡•á‡§Ç‡•§
java
Copy
Edit
for (int j = i; j < arr.length; j++) {
j ‡§∏‡•á ‡§è‡§ï ‡§®‡§Ø‡§æ subarray ‡§¨‡§®‡§æ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è inner loop ‡§ö‡§≤‡§æ‡§Ø‡§æ‡•§
6. Element Add ‡§ï‡§∞‡§®‡§æ ‡§î‡§∞ Checking
java
Copy
Edit
set.add(arr[j]); // subarray ‡§Æ‡•á‡§Ç element add ‡§ï‡§∞‡•ã
set ‡§Æ‡•á‡§Ç arr[j] ‡§ï‡•ã insert ‡§ï‡§ø‡§Ø‡§æ, ‡§§‡§æ‡§ï‡§ø ‡§π‡§Æ ‡§Ø‡§π track ‡§ï‡§∞ ‡§∏‡§ï‡•á‡§Ç ‡§ï‡§ø subarray ‡§Æ‡•á‡§Ç ‡§ï‡§ø‡§§‡§®‡•á distinct elements ‡§π‡•à‡§Ç‡•§
java
Copy
Edit
if (set.size() > 2) break; // ‡§Ö‡§ó‡§∞ 2 ‡§∏‡•á ‡§ú‡•ç‡§Ø‡§æ‡§¶‡§æ distinct elements ‡§π‡•ã ‡§ó‡§è ‡§§‡•ã break
‡§Ö‡§ó‡§∞ set ‡§ï‡•Ä size 2 ‡§∏‡•á ‡§ú‡•ç‡§Ø‡§æ‡§¶‡§æ ‡§π‡•ã ‡§ú‡§æ‡§è, ‡§§‡•ã ‡§π‡§Æ loop ‡§ï‡•ã break ‡§ï‡§∞ ‡§¶‡•á‡§§‡•á ‡§π‡•à‡§Ç ‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø ‡§Ø‡§π subarray ‡§Ö‡§¨ valid ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡•§
7. maxLength ‡§ï‡•ã Update ‡§ï‡§∞‡§®‡§æ
java
Copy
Edit
maxLength = Math.max(maxLength, j - i + 1); // max length update ‡§ï‡§∞‡•ã
j - i + 1 ‡§∏‡•á subarray ‡§ï‡•Ä current length ‡§®‡§ø‡§ï‡§æ‡§≤‡•Ä ‡§î‡§∞ maxLength ‡§ï‡•ã update ‡§ï‡§ø‡§Ø‡§æ‡•§
8. Return Statement
java
Copy
Edit
return maxLength;
‡§™‡•Ç‡§∞‡•Ä array ‡§ï‡•ã ‡§ö‡•á‡§ï ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§¨‡§æ‡§¶, ‡§π‡§Æ‡•á‡§Ç ‡§∏‡§¨‡§∏‡•á ‡§¨‡§°‡§º‡§æ valid subarray ‡§Æ‡§ø‡§≤‡§æ ‡§π‡•ã‡§ó‡§æ‡•§ ‡§â‡§∏‡•á return ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ‡•§
9. main() Method - Test Cases Run ‡§ï‡§∞‡§®‡§æ
java
Copy
Edit
public static void main(String[] args) {
main() method ‡§Æ‡•á‡§Ç test cases ‡§ï‡•ã check ‡§ï‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ‡•§
java
Copy
Edit
Integer arr1[] = {2, 1, 2};
System.out.println(totalElements(arr1)); // Output: 3
{2, 1, 2} subarray ‡§™‡•Ç‡§∞‡§æ valid ‡§π‡•à, ‡§á‡§∏‡§≤‡§ø‡§è output 3 ‡§Ü‡§è‡§ó‡§æ‡•§
java
Copy
Edit
Integer arr2[] = {3, 1, 2, 2, 2, 2};
System.out.println(totalElements(arr2)); // Output: 5
{1, 2, 2, 2, 2} ‡§Ø‡§π ‡§∏‡§¨‡§∏‡•á ‡§¨‡§°‡§º‡§æ valid subarray ‡§π‡•à, ‡§ú‡§ø‡§∏‡§ï‡§æ size 5 ‡§π‡•à‡•§
Dry Run (Step by Step Execution)
Test Case 1: arr = {2, 1, 2}
i	j	Subarray	Unique Elements	maxLength
0	0	{2}	{2}	1
0	1	{2, 1}	{2, 1}	2
0	2	{2, 1, 2}	{2, 1}	3
1	1	{1}	{1}	3
1	2	{1, 2}	{1, 2}	3
2	2	{2}	{2}	3
‚úÖ Final Output = 3

Test Case 2: arr = {3, 1, 2, 2, 2, 2}
i	j	Subarray	Unique Elements	maxLength
0	0	{3}	{3}	1
0	1	{3, 1}	{3, 1}	2
0	2	{3, 1, 2}	{3, 1, 2}	- (break)
1	1	{1}	{1}	2
1	2	{1, 2}	{1, 2}	2
1	3	{1, 2, 2}	{1, 2}	3
1	4	{1, 2, 2, 2}	{1, 2}	4
1	5	{1, 2, 2, 2, 2}	{1, 2}	5
2	2	{2}	{2}	5
2	3	{2, 2}	{2}	5
2	4	{2, 2, 2}	{2}	5
2	5	{2, 2, 2, 2}	{2}	5
‚úÖ Final Output = 5

‡§∏‡§Æ‡§æ‡§™‡•ç‡§§‡§ø üéØ
Time Complexity: O(n^2) (‡§¶‡•ã nested loops)
Space Complexity: O(2) = O(1) (‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø set ‡§Æ‡•á‡§Ç ‡§∏‡§ø‡§∞‡•ç‡§´ 2 elements ‡§π‡•ã‡§Ç‡§ó‡•á)
‡§á‡§∏ approach ‡§ï‡•ã Sliding Window ‡§∏‡•á ‡§î‡§∞ optimize ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ ‡§∏‡§ï‡§§‡§æ ‡§π‡•à üöÄ.








You said:
why we use HashSet<Integer> 
short explain
ChatGPT said:
‡§π‡§Æ HashSet<Integer> ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§á‡§∏‡§≤‡§ø‡§è ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç ‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø:

Distinct (‡§Ö‡§≤‡§ó-‡§Ö‡§≤‡§ó) Elements ‡§ï‡•ã Store ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è

HashSet automatically duplicate values ‡§ï‡•ã allow ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞‡§§‡§æ‡•§ ‡§á‡§∏‡§∏‡•á ‡§π‡§Æ ‡§Ü‡§∏‡§æ‡§®‡•Ä ‡§∏‡•á check ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç ‡§ï‡§ø subarray ‡§Æ‡•á‡§Ç ‡§ï‡§ø‡§§‡§®‡•á unique elements ‡§π‡•à‡§Ç‡•§
Fast Lookup (O(1) Average Case)

set.size() ‡§∏‡•á ‡§π‡§Æ ‡§ú‡§≤‡•ç‡§¶‡•Ä ‡§∏‡•á check ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç ‡§ï‡§ø subarray ‡§Æ‡•á‡§Ç ‡§ï‡§ø‡§§‡§®‡•á distinct elements ‡§π‡•à‡§Ç, ‡§ú‡§ø‡§∏‡§∏‡•á ‡§π‡§Æ‡§æ‡§∞‡§æ code efficient ‡§¨‡§®‡§§‡§æ ‡§π‡•à‡•§
Condition Checking for Breaking the Loop

‡§ú‡§¨ set.size() > 2 ‡§π‡•ã ‡§ú‡§æ‡§§‡§æ ‡§π‡•à, ‡§§‡•ã ‡§π‡§Æ‡•á‡§Ç ‡§™‡§§‡§æ ‡§ö‡§≤ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à ‡§ï‡§ø subarray ‡§Ö‡§¨ valid ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à, ‡§î‡§∞ ‡§π‡§Æ ‡§§‡•Å‡§∞‡§Ç‡§§ loop ‡§ï‡•ã break ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§
‚úÖ Conclusion: HashSet<Integer> ‡§π‡§Æ‡•á‡§Ç fast ‡§î‡§∞ easy ‡§§‡§∞‡•Ä‡§ï‡•á ‡§∏‡•á unique elements track ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§Æ‡§¶‡§¶ ‡§ï‡§∞‡§§‡§æ ‡§π‡•à! üöÄ







You said:
what type of brackets come in hashset
ChatGPT said:
In Java, when you declare or initialize a HashSet, you use curly braces { } to define the contents of the set, and angle brackets < > to specify the type of the elements inside the set. Here's the breakdown:

Angle Brackets < >:

These are used to specify the type of elements the HashSet will store. In your case, HashSet<Integer> means the set will store Integer values.
Example:

java
Copy
Edit
HashSet<Integer> set = new HashSet<>();
Curly Braces { }:

These are used to define the initial elements of a HashSet when you initialize it. However, you cannot directly initialize a HashSet with values inside curly braces unless you are using an initializer block or using something like Arrays.asList().
Example of initializing a HashSet with values:

java
Copy
Edit
HashSet<Integer> set = new HashSet<>(Arrays.asList(1, 2, 3, 4));
To Summarize:
Angle Brackets < > specify the type of the elements.
Curly Braces { } are used for initializing elements inside a collection.






